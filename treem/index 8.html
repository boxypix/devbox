<!-- tree.html -->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Metric Tree — B2C</title>
  <style>
    @font-face {
      font-family: "Tilda Sans";
      src: url("fonts/TildaSans-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "Tilda Sans";
      src: url("fonts/TildaSans-Medium.woff") format("woff");
      font-weight: 500;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "Tilda Sans";
      src: url("fonts/TildaSans-Semibold.woff") format("woff");
      font-weight: 600;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "Tilda Sans";
      src: url("fonts/TildaSans-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "Tilda Sans";
      src: url("fonts/TildaSans-ExtraBold.woff") format("woff");
      font-weight: 800;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "Tilda Sans";
      src: url("fonts/TildaSans-Black.woff") format("woff");
      font-weight: 900;
      font-style: normal;
      font-display: swap;
    }

    /* Cursor dark, фон чёрный, шрифт Tilda Sans */
    :root{
      --bg: #000000;
      --panel: #0d0d0d;
      --panel2: #141414;
      --line: #1f1f1f;
      --line-hover: #2a2a2a;
      --input-bg: #1a1a1a;
      --text: #d4d4d4;
      --muted: #6e6e6e;
      --accent: #3794ff;
      --accent-hover: #4da3ff;
      --accent2: #569cd6;
      --danger: #f48771;
      --shadow: 0 2px 8px rgba(0,0,0,.6);
      --r: 6px;
      --sans: "Tilda Sans", ui-sans-serif, system-ui, -apple-system, sans-serif;
      --mono: "Tilda Sans", ui-sans-serif, system-ui, sans-serif;
      --graph-node-font-size: 8px;
      --graph-node-parent-font-size: 8px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: var(--bg);
      color: var(--text);
    }
    header{
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      border-bottom: 1px solid var(--line);
      background: var(--panel);
      position: sticky; top: 0; z-index: 10;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 220px;
    }
    .title h1{
      margin:0;
      font-size:16px;
      font-weight:900;
      letter-spacing:.3px;
    }
    .title .sub{
      font-size:12px;
      color:var(--muted);
    }
    .search{
      flex:1;
      display:flex;
      gap:10px;
      align-items:center;
    }
    input[type="search"]{
      width: 100%;
      padding: 8px 12px;
      border-radius: var(--r);
      border: 1px solid var(--line);
      background: var(--input-bg);
      color: var(--text);
      outline: none;
    }
    input[type="search"]:focus{
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent);
    }
    .btn{
      padding: 8px 12px;
      border-radius: var(--r);
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      cursor: pointer;
      user-select: none;
    }
    .btn:hover{
      border-color: var(--line-hover);
      background: var(--line-hover);
    }
    .layout{
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 12px;
      padding: 12px;
      height: calc(100% - 52px);
    }
    .card{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 0;
    }
    .treeWrap{
      display:flex;
      flex-direction:column;
      min-height:0;
      height:100%;
    }
    .treeSearchRow{
      flex: 0 0 auto;
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid var(--line);
      background: var(--panel2);
    }
    .treeSearchRow input[type="search"]{
      flex:1;
      min-width:0;
    }
    .treeSearchRow .btn{
      flex:0 0 auto;
      min-width:32px;
      padding:8px 10px;
    }
    .treeScroll{
      flex:1;
      min-height:0;
      overflow:auto;
      padding:8px 8px 12px;
    }
    .detailWrap{
      padding:14px;
      overflow:auto;
      height:100%;
    }
    .node{
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 6px 8px;
      border-radius: var(--r);
      cursor: pointer;
      border: 1px solid transparent;
    }
    .node:hover{
      background: var(--panel2);
      border-color: var(--line);
    }
    .node.active{
      background: var(--input-bg);
      border-color: var(--line-hover);
    }
    .node .dot{
      width: 10px; height: 10px;
      border-radius: 999px;
      margin-top: 4px;
      flex: 0 0 auto;
    }
    .node .meta{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
      flex:1;
    }
    .node .name{
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .node .code{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }
    .node .tog{
      font-family: var(--mono);
      color: var(--muted);
      padding: 0 6px;
      border: 1px solid var(--line);
      border-radius: var(--r);
      line-height: 18px;
      height: 20px;
      margin-top: 1px;
      flex: 0 0 auto;
      background: var(--input-bg);
    }
    .children{
      margin-left: 14px;
      padding-left: 10px;
      border-left: 1px dashed var(--line);
    }
    .badge{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: var(--r);
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--muted);
      font-size: 12px;
    }
    .badge strong{color:var(--text); font-weight:700}
    .h2{
      margin:0 0 6px 0;
      font-size:68px;
      font-weight:900;
      letter-spacing:.2px;
    }
    .p{margin: 0 0 10px 0; color: var(--text); line-height: 1.5}
    .muted{color: var(--muted)}
    .grid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    .box{
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 12px;
      background: var(--panel2);
    }
    .box h3{
      margin:0 0 6px 0;
      font-size:12px;
      color: var(--muted);
      font-weight:600;
      letter-spacing:.2px;
      text-transform:uppercase;
    }
    ul{margin: 0; padding-left: 18px}
    li{margin: 6px 0; color: var(--text); line-height: 1.45}
    .crumbs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin: 0 0 10px 0;
      align-items:center;
    }
    .crumbs a{
      color: var(--accent);
      text-decoration: none;
      font-size: 12px;
      border: 1px solid var(--line);
      background: var(--panel2);
      padding: 5px 9px;
      border-radius: var(--r);
    }
    .crumbs a:hover{border-color: var(--accent); background: var(--input-bg)}
    .empty{
      padding: 16px;
      color: var(--muted);
      font-size: 13px;
      border: 1px dashed var(--line);
      border-radius: var(--r);
      background: var(--panel2);
    }
    .footerNote{
      margin-top: 14px;
      font-size: 12px;
      color: var(--muted);
    }
    .metricGraph{
      margin: 0 0 16px 0;
      padding: 12px;
      border: 1px solid var(--line);
      border-radius: var(--r);
      background: var(--panel2);
      overflow: auto;
    }
    .metricGraph h3{
      margin:0 0 10px 0;
      font-size:11px;
      color: var(--muted);
      font-weight:600;
      letter-spacing:.2px;
      text-transform:uppercase;
    }
    .metricGraphSvg{
      display:block;
      width:100%;
      min-height:140px;
    }
    .graphLink{
      stroke: var(--line);
      stroke-width:1.5;
      fill:none;
      opacity:.8;
    }
    .graphNode{
      cursor:pointer;
      transition: transform .15s ease, filter .15s ease;
    }
    .graphNode:hover{
      filter: brightness(1.2);
    }
    .graphNode rect{
      fill: var(--panel2);
      stroke: var(--line);
      stroke-width: 1.5;
      transition: stroke .15s ease, stroke-width .15s ease;
    }
    .graphNode:hover rect{
      stroke: var(--accent);
      stroke-width: 2;
    }
    .graphNode.active rect{
      stroke: var(--accent2);
      stroke-width: 2;
      filter: drop-shadow(0 0 6px rgba(86, 156, 214, .25));
    }
    .graphNode text{
      font: var(--graph-node-font-size) var(--mono);
      fill: var(--text);
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: central;
    }
    .graphNode.active text{
      fill: var(--accent2);
      font-weight: 700;
    }
    .graphNode.parent rect{
      fill: var(--panel);
      stroke: var(--line);
    }
    .graphNode.parent text{
      fill: var(--muted);
      font-size: var(--graph-node-parent-font-size);
    }
    .graphNode.parent:hover rect{
      stroke: var(--line-hover);
      fill: var(--input-bg);
    }
    .graphNode.parent:hover text{
      fill: var(--text);
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr; height:auto}
      .card{min-height: 40vh}
      header{position:relative}
    }
  </style>
</head>

<body>
  <header>
    <div class="title">
      <h1>Дерево метрик (B2C)</h1>
      <div class="sub">NSM → Acquisition → Activation → Engagement → Retention → Monetization</div>
    </div>
  </header>

  <main class="layout">
    <section class="card">
      <div class="treeWrap">
        <div class="treeSearchRow">
          <input id="q" type="search" placeholder="Поиск по названию, коду (например: D7), тегам…" autocomplete="off" />
          <button class="btn" id="expandAll" title="Развернуть всё">E</button>
          <button class="btn" id="collapseAll" title="Свернуть всё">C</button>
        </div>
        <div class="treeScroll" id="tree"></div>
      </div>
    </section>

    <section class="card">
      <div class="detailWrap" id="detail">
        <div class="empty">Выбери метрику слева — справа появится описание, зачем важно и как улучшать.</div>
      </div>
    </section>
  </main>

  <script>
    // Данные дерева метрик — встроены, чтобы работало без сервера (file://)
    window.METRIC_TREE = {"id":"root","code":"TREE","name":"Дерево продуктовых метрик (B2C)","short":"Единая структура метрик: NSM → Acquisition → Activation → Engagement → Retention → Monetization + Quality + Unit economics.","why":"Помогает связать продуктовую ценность (NSM) с драйверами роста и найти точку, где ломается воронка/качество/экономика.","tags":["framework","b2c"],"howImprove":["Определи NSM под конкретный продукт (не 'MAU')","Повесь на каждую ветку 1–2 ведущих метрики (leading) и 1–2 итоговых (lagging)","Делай срезы по когортам: канал/страна/версия/пейволл/сегмент"],"pitfalls":["Пытаться оптимизировать всё сразу — метрики начнут конфликтовать","Подменять ценность 'временем в приложении' или 'кол-вом экранов'","Смешивать платный и органический трафик без когорт"],"related":["NSM","D7","LTV","CAC"],"children":[{"id":"nsm","code":"NSM","name":"North Star Metric (NSM)","short":"Одна метрика, которая лучше всего отражает полученную пользователем ценность.","why":"Фокусирует команду на value, а не на суетных прокси (трафик/просмотры).","formula":"NSM = users_with_core_value_event_per_period (например, weekly users who completed core action)","tags":["strategy","value"],"howImprove":["Определи core value event (1–2 события максимум)","Уменьши Time to Value (TTV) и трение в первых шагах","Увеличивай частоту core action и возвраты (retention)","Убирай деградации качества (crash/latency)"],"pitfalls":["Выбрать NSM = MAU/DAU (это размер, а не ценность)","Выбрать действие, которое легко накрутить (vanity)","Не зафиксировать период и правило подсчёта"],"related":["AHA","TTV","CoreActionFreq","D7"]},{"id":"acq","code":"ACQ","name":"Acquisition (Привлечение)","short":"Как пользователи узнают о продукте и доходят до установки/регистрации.","why":"Определяет масштаб верхней воронки и качество входящего потока.","tags":["growth","marketing"],"howImprove":["ASO/SEO, локализация, скриншоты/видео","Тест креативов и сегментов","Стабильный микс каналов (не зависеть от одного)"],"pitfalls":["Сравнивать каналы без нормализации по когортам и качеству","Оптимизировать CPI в ущерб retention (дешёвый трафик = мёртвый)"],"children":[{"id":"impr","code":"Impressions","name":"Impressions / Reach","short":"Сколько людей увидели продукт/креатив/страницу.","why":"Без масштаба вверху воронки нечего оптимизировать ниже.","formula":"Impressions = count(ad_impressions) или store_page_impressions","tags":["top-funnel"],"howImprove":["Расширять охват каналов","Улучшать ASO/SEO","Партнёрки/рефералки/PR"],"pitfalls":["Рост показов без CTR/CVR — пустая метрика"],"related":["CTR","CVR_Install"]},{"id":"ctr","code":"CTR","name":"CTR (Click-through rate)","short":"Клики / показы.","why":"Сигнал качества сообщения и попадания в аудиторию.","formula":"CTR = clicks / impressions","tags":["top-funnel"],"howImprove":["Тестировать офферы и креативы","Сегментировать аудиторию","Сильный first frame (видео/скрин)"],"pitfalls":["Высокий CTR с низким CVR — кликбейт/не тот оффер"],"related":["CVR_Install","CPI"]},{"id":"cvr_install","code":"CVR_Install","name":"Install Conversion Rate","short":"Установки / визиты в стор или лендинг.","why":"Насколько страница продукта продаёт обещание.","formula":"CVR_Install = installs / store_page_visits","tags":["store","landing"],"howImprove":["Скриншоты: боль→выгода","Видео демо ценности","Локализация, социальное доказательство"],"pitfalls":["Менять страницу без A/B и без контроля сезона/канала"],"related":["Rating","Reviews","CPI"]},{"id":"cpi","code":"CPI/CPA","name":"CPI / CPA","short":"Стоимость установки или целевого действия.","why":"Понимание масштабируемости маркетинга.","formula":"CPI = spend / installs; CPA = spend / target_actions","tags":["unit-econ","ads"],"howImprove":["События оптимизации ближе к value","Отключать слабые сегменты","Качество onboarding/retention"],"pitfalls":["Оптимизировать CPI без LTV и retention"],"related":["LTV","CAC","Payback"]},{"id":"channel_mix","code":"ChannelMix","name":"Channel Mix","short":"Доля каналов (органика/платка/реферал/PR).","why":"Снижает риск зависимости от одного источника.","tags":["strategy"],"howImprove":["Растить органику","Запускать рефералки","Контент и PR"],"pitfalls":["Смешивать органику с платкой в одном графике без разделения когорт"],"related":["Impressions","CPI/CPA"]}]},{"id":"act","code":"ACT","name":"Activation (Активация / First Value)","short":"Получил ли новый пользователь первую реальную пользу и насколько быстро.","why":"Activation — главный драйвер retention: без first value пользователь не вернётся.","tags":["onboarding","aha"],"howImprove":["Сокращать Time to Value","Убирать обязательную регистрацию","Дефолты и шаблоны"],"pitfalls":["Считать completion онбординга вместо 'получил value'"],"children":[{"id":"aha","code":"AHA","name":"Activation Rate (Aha-rate)","short":"% новых пользователей, совершивших 'первое ценностное действие' в первые X минут/дней.","why":"Если Aha низкий — дальше любые улучшения монетизации бесполезны.","formula":"AHA = new_users_with_value_event_in_X / new_users","tags":["leading"],"howImprove":["Определить value-event","Срезать шаги до value","Сделать демо/превью ценности до логина"],"pitfalls":["Value-event выбран слишком легким или не связан с ценностью"],"related":["TTV","D1","OnboardingCompletion"]},{"id":"ttv","code":"TTV","name":"Time to Value (TTV)","short":"Время до первого полезного результата.","why":"Чем дольше TTV — тем выше ранний отвал.","formula":"TTV = time(value_event) - time(first_open)","tags":["onboarding","ux"],"howImprove":["Гостевой режим","Автозаполнение","Шаблоны","Сократить permissions до момента пользы"],"pitfalls":["Считать время до регистрации вместо времени до value"],"related":["AHA","D1"]},{"id":"onb","code":"OnbCompletion","name":"Onboarding Completion","short":"% завершивших онбординг.","why":"Показывает трение в первых шагах (но это прокси, не цель).","formula":"OnbCompletion = users_completed_onboarding / new_users","tags":["proxy"],"howImprove":["Резать шаги","Прогрессивный онбординг","Больше дефолтов"],"pitfalls":["Оптимизировать completion ценой качества (люди проходят, но не получают value)"],"related":["AHA","TTV"]},{"id":"perm","code":"OptIn","name":"Permission Opt-in Rate","short":"% согласившихся на разрешения (push/location/health).","why":"Влияет на ключевые фичи и коммуникации (особенно push).","formula":"OptIn = users_granted_permission / users_prompted","tags":["push","privacy"],"howImprove":["Просить just-in-time","Объяснять выгоду","Дать альтернативу без пермишена"],"pitfalls":["Просить разрешение в первые секунды без контекста"],"related":["PushOpenRate","D7"]}]},{"id":"eng","code":"ENG","name":"Engagement (Использование)","short":"Как часто и насколько глубоко люди используют продукт.","why":"Engagement = привычка/повторяемость ценности; без него retention проседает.","tags":["usage"],"howImprove":["Поводы вернуться","Персонализация","Улучшать discoverability фич"],"pitfalls":["Считать 'время в приложении' как успех"],"children":[{"id":"dau","code":"DAU/WAU/MAU","name":"DAU / WAU / MAU","short":"Активные пользователи за день/неделю/месяц.","why":"Размер активной базы (лагирующий индикатор).","formula":"DAU = distinct users with any session per day","tags":["volume"],"howImprove":["Улучшать retention","Поводы вернуться","Сегментация и win-back"],"pitfalls":["Рост DAU без NSM/core action — мнимая активность"],"related":["Stickiness","CoreActionFreq"]},{"id":"stick","code":"Stickiness","name":"Stickiness (DAU/MAU или WAU/MAU)","short":"Доля месячной аудитории, которая активна каждый день/неделю.","why":"Понимаешь: продукт — привычка или редкая нужда.","formula":"Stickiness = DAU/MAU (или WAU/MAU)","tags":["habit"],"howImprove":["Регулярные сценарии","Контент/триггеры","Стабильные циклы ценности"],"pitfalls":["Сравнивать разные категории продуктов по одному порогу stickiness"],"related":["DAU/WAU/MAU","Retention"]},{"id":"sess_u","code":"SessionsPerUser","name":"Sessions per user","short":"Сколько сессий на пользователя за период.","why":"Прокси частоты использования (лучше вместе с core action).","formula":"SessionsPerUser = sessions / active_users","tags":["frequency"],"howImprove":["Ускорить ключевые сценарии","Сделать повторяемые задачи проще","Внятные entry points"],"pitfalls":["Сессии растут из-за багов/фрустрации (люди 'переоткрывают')"],"related":["CoreActionFreq","Latency"]},{"id":"feat_adopt","code":"FeatureAdoption","name":"Feature Adoption","short":"Доля пользователей, использующих конкретную фичу.","why":"Понимаешь, что реально работает, а что мёртвое.","formula":"FeatureAdoption = users_used_feature / active_users","tags":["feature"],"howImprove":["Discoverability","Контекстные подсказки","Умные дефолты"],"pitfalls":["Давить подсказками/баннерами и портить UX"],"related":["AHA","CoreActionFreq"]},{"id":"core_freq","code":"CoreActionFreq","name":"Core Action Frequency","short":"Сколько раз пользователь делает ключевое действие за период.","why":"Ближе всего к ценности и NSM.","formula":"CoreActionFreq = core_actions / active_users (per week/month)","tags":["value","leading"],"howImprove":["Снизить трение","Сделать быстрые повторения","Персональные сценарии"],"pitfalls":["Выбрать не то 'core action' и оптимизировать шум"],"related":["NSM","D7"]}]},{"id":"ret","code":"RET","name":"Retention (Удержание)","short":"Возвращаются ли пользователи и остаются ли они активными по когортам.","why":"Если retention слабый — рост всегда будет 'дырявым ведром'.","tags":["cohorts"],"howImprove":["Улучшать activation","Закрывать топ-причины ухода","Win-back и качественные пуши"],"pitfalls":["Смешивать когорты разных каналов и версий"],"children":[{"id":"d1","code":"D1","name":"D1 Retention","short":"% вернувшихся на следующий день после установки.","why":"Проверка: был ли хоть какой-то value на старте.","formula":"D1 = users_active_on_day1 / installs_on_day0","tags":["baseline"],"howImprove":["Сокращать TTV","Улучшать Aha","Стабильность/перфоманс"],"pitfalls":["Ранние пуши без ценности дают short-term клики, но убивают доверие"],"related":["AHA","TTV","CrashFree"]},{"id":"d7","code":"D7","name":"D7 Retention","short":"% вернувшихся на 7-й день после установки.","why":"Сигнал формирования привычки/регулярной пользы.","formula":"D7 = users_active_on_day7 / installs_on_day0","tags":["habit"],"howImprove":["Поводы вернуться","Персонализация","Контент/циклы ценности"],"pitfalls":["Сравнивать D7 между разными категориями продуктов без контекста"],"related":["Stickiness","CoreActionFreq"]},{"id":"d30","code":"D30","name":"D30 Retention","short":"% вернувшихся на 30-й день.","why":"Стабильная ценность + качество + монетизация без боли.","formula":"D30 = users_active_on_day30 / installs_on_day0","tags":["long-term"],"howImprove":["Улучшать продуктовый loop","Снижать churn","Качество и roadmap"],"pitfalls":["Держать людей только скидками/спамом"],"related":["Churn","LTV"]},{"id":"cohort","code":"CohortRet","name":"Cohort Retention","short":"Retention по когортам: канал/страна/версия/сегмент.","why":"Находит 'где ломается' и где рост — точечно, а не в среднем по больнице.","formula":"Retention segmented by {channel,country,app_version,paywall_variant}","tags":["diagnostic"],"howImprove":["Сегментные фиксы","Локализация","Фиксы по версиям"],"pitfalls":["Мало данных → шум. Смотри доверительные интервалы/объёмы."],"related":["D7","ChannelMix","PaywallCVR"]},{"id":"churn","code":"Churn","name":"Churn Rate","short":"% пользователей, переставших быть активными за период.","why":"Обратная сторона retention: показывает 'утечку'.","formula":"Churn = users_lost / users_at_start (definition depends on app)","tags":["loss"],"howImprove":["Найти причины ухода","Улучшить core value","Стабильность/UX"],"pitfalls":["Разные определения активности → разные churn"],"related":["D30","WinBack"]},{"id":"winback","code":"WinBack","name":"Re-activation / Win-back","short":"Доля вернувшихся после периода неактивности.","why":"Дешёвый рост без нового трафика.","formula":"WinBack = resurrected_users / dormant_users","tags":["growth"],"howImprove":["Персональные кампании","Новые поводы","Пуши по реальному триггеру"],"pitfalls":["Спамить 'вернись' без конкретной выгоды"],"related":["PushOpenRate","NSM"]}]},{"id":"mon","code":"MON","name":"Monetization (Монетизация)","short":"Как продукт превращает ценность в деньги (подписка/покупки/реклама).","why":"Без здоровой монетизации продукт не масштабируется (или начинает душить UX).","tags":["revenue"],"howImprove":["Тайминг и сегментация paywall","Понятный value","Годовые планы и бандлы"],"pitfalls":["Давить paywall до value → убить activation/retention"],"children":[{"id":"pay_cvr","code":"PaywallCVR","name":"Conversion to Paid","short":"% перешедших в оплату (free→paid / trial→paid).","why":"Главная продуктовая метрика дохода для подписочных моделей.","formula":"PaywallCVR = paid_users / paywall_viewers (или trial_to_paid)","tags":["subscription"],"howImprove":["Показывать paywall после value","Паковать выгоды, не фичи","Сегменты и A/B"],"pitfalls":["Мерить только конверсию, игнорируя refunds и churn платящих"],"related":["ARPU","RefundRate","LTV"]},{"id":"arpu","code":"ARPU/ARPPU","name":"ARPU / ARPPU","short":"Средний доход на пользователя / на платящего.","why":"Понимаешь качество монетизации и потенциал прайса.","formula":"ARPU = revenue / active_users; ARPPU = revenue / paying_users","tags":["pricing"],"howImprove":["Тарифная сетка","Апселлы","Годовые планы","Бандлы"],"pitfalls":["Поднимать ARPU ценой churn (короткий всплеск, потом падение)"],"related":["LTV","Payback"]},{"id":"ltv","code":"LTV","name":"LTV (Lifetime Value)","short":"Ожидаемый доход за 'жизнь' пользователя.","why":"Определяет допустимый CAC и масштабирование.","formula":"LTV ≈ ARPU * avg_lifetime (или модель по retention кривой)","tags":["unit-econ"],"howImprove":["Повышать retention","Улучшать paywall CVR","Снижать refunds"],"pitfalls":["Считать LTV без когорт и без канала → ложная уверенность"],"related":["CAC","LTV/CAC"]},{"id":"refund","code":"RefundRate","name":"Refund / Chargeback Rate","short":"Доля возвратов и спорных списаний.","why":"Сигнал проблем с обещанием, UX оплаты или качеством продукта.","formula":"RefundRate = refunds / purchases","tags":["trust"],"howImprove":["Чёткое обещание в paywall","Честный trial","Стабильность и поддержка"],"pitfalls":["Пытаться 'скрыть отмену' — это удар по репутации"],"related":["Rating","Reviews"]},{"id":"mrr","code":"MRR/ARR","name":"Revenue / MRR / ARR","short":"Общий доход и подписочный доход в месяц/год.","why":"Бизнес-результат и устойчивость.","formula":"MRR = Σ(subscription_monthly_equivalent)","tags":["business"],"howImprove":["Ret. платящих","Годовые планы","Уменьшать churn платящих"],"pitfalls":["Расти MRR за счёт скидок без удержания"],"related":["PaywallCVR","PaidChurn"]}]},{"id":"qual","code":"QUAL","name":"Quality & Reliability (Качество)","short":"Стабильность, скорость и ощущение надёжности продукта.","why":"Качество напрямую влияет на activation/retention и рейтинги в сторах.","tags":["performance","stability"],"howImprove":["Приоритизировать топ-краши","Оптимизировать латентность","Наблюдаемость (monitoring)"],"pitfalls":["Игнорировать перфоманс на средних девайсах"],"children":[{"id":"crashfree","code":"CrashFree","name":"Crash-free users/sessions","short":"Доля пользователей/сессий без крашей.","why":"Краши убивают доверие и удержание.","formula":"CrashFree = 1 - (crash_users / active_users)","tags":["stability"],"howImprove":["Фикс топ-крашей","QA на ключевых девайсах","Feature flags"],"pitfalls":["Фокус только на % без анализа impact (какие экраны/сегменты)"],"related":["D1","Rating"]},{"id":"latency","code":"Latency","name":"Latency / Load time","short":"Скорость запуска/загрузки экранов/API.","why":"Скорость = конверсия и удержание.","formula":"p50/p95 load_time for key screens","tags":["performance"],"howImprove":["Кэш","Lazy-load","Скелетоны","Оптимизация запросов"],"pitfalls":["Оптимизировать среднее, игнорируя p95 (хвост боли)"],"related":["TTV","SessionsPerUser"]},{"id":"rating","code":"Rating","name":"Store Rating","short":"Средняя оценка приложения.","why":"Влияет на органику и доверие.","formula":"Avg rating in App Store / Google Play","tags":["store"],"howImprove":["Просить оценку после value","Закрывать топ-проблемы","Поддержка/FAQ"],"pitfalls":["Просить оценку на первом запуске"],"related":["Reviews","CVR_Install"]},{"id":"reviews","code":"Reviews","name":"Reviews sentiment","short":"Тональность и темы отзывов.","why":"Быстрый источник проблем/инсайтов, влияет на конверсию в установку.","formula":"Topic clusters + sentiment (manual/auto)","tags":["voice-of-customer"],"howImprove":["Кластеризация тем","Ответы на ключевые","Fix top pains"],"pitfalls":["Реагировать на единичные отзывы без данных"],"related":["Rating","RefundRate"]}]},{"id":"ue","code":"UE","name":"Unit Economics (Экономика)","short":"Связывает Acquisition + Monetization + Retention и отвечает: можно ли масштабироваться.","why":"Если LTV/CAC плохой — рост будет пожирать деньги.","tags":["finance"],"howImprove":["Повышать LTV","Снижать CAC","Ускорять payback"],"pitfalls":["Считать экономику без когорт и payback"],"children":[{"id":"cac","code":"CAC","name":"CAC (Customer Acquisition Cost)","short":"Стоимость привлечения платящего/целевого пользователя.","why":"Определяет, сколько можно тратить на рост.","formula":"CAC = spend / acquired_paying_users (or qualified users)","tags":["ads"],"howImprove":["Оптимизация каналов","Повышать конверсию в оплату","Сегментация"],"pitfalls":["Считать CAC по установкам вместо платящих/квалифицированных"],"related":["LTV","Payback"]},{"id":"ltvcac","code":"LTV/CAC","name":"LTV/CAC","short":"Соотношение ценности к стоимости привлечения.","why":"Проверка жизнеспособности роста.","formula":"LTV/CAC = LTV / CAC","tags":["health"],"howImprove":["Ret. платящих","Прайс/упаковка","Снижение refunds"],"pitfalls":["Игнорировать время окупаемости (payback)"],"related":["LTV","CAC","Payback"]},{"id":"payback","code":"Payback","name":"Payback Period","short":"За сколько окупается CAC.","why":"Влияет на кэш-флоу и риск.","formula":"Payback = time until cumulative margin >= CAC","tags":["cashflow"],"howImprove":["Ранняя монетизация","Годовые планы","Снижение churn"],"pitfalls":["Окупаемость 'на бумаге' без учёта refunds"],"related":["RefundRate","MRR/ARR"]}]}]};
  </script>
  <script>
    const METRIC_TREE = window.METRIC_TREE;

    const $tree = document.getElementById("tree");
    const $detail = document.getElementById("detail");
    const $q = document.getElementById("q");
    const $countShown = document.getElementById("countShown");
    const $activeCode = document.getElementById("activeCode");
    const setCountShown = (v) => { if ($countShown) $countShown.textContent = v; };
    const setActiveCode = (v) => { if ($activeCode) $activeCode.textContent = v; };

    const state = {
      expanded: new Set(),
      activeId: null,
      flat: [],
      parentById: new Map(),
      nodeById: new Map(),
      childrenById: new Map(),
      lastQuery: ""
    };

    function encodeHtml(str){
      return (str == null ? "" : String(str))
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function renderFatal(message){
      const safe = encodeHtml(message);
      $tree.innerHTML = `<div class="empty">Ошибка загрузки дерева: ${safe}</div>`;
      $detail.innerHTML = `<div class="empty">Проверь структуру <code>METRIC_TREE</code> в этой странице.</div>`;
      setCountShown("0");
      setActiveCode("ERR");
    }

    function validateTree(root){
      const problems = [];
      const seen = new Set();

      function walk(node, path){
        if (!node || typeof node !== "object") {
          problems.push(`${path}: узел должен быть объектом`);
          return;
        }
        if (!node.id || typeof node.id !== "string") problems.push(`${path}: отсутствует string id`);
        if (!node.name || typeof node.name !== "string") problems.push(`${path}: отсутствует string name`);
        if (!node.code || typeof node.code !== "string") problems.push(`${path}: отсутствует string code`);
        if (node.id) {
          if (seen.has(node.id)) problems.push(`${path}: дублирующийся id "${node.id}"`);
          seen.add(node.id);
        }
        const kids = node.children ?? [];
        if (!Array.isArray(kids)) {
          problems.push(`${path}: children должен быть массивом`);
          return;
        }
        for (let i = 0; i < kids.length; i++) {
          const child = kids[i];
          const idHint = child && typeof child === "object" ? (child.id || `#${i}`) : `#${i}`;
          walk(child, `${path}/${idHint}`);
        }
      }

      walk(root, "root");
      return problems;
    }

    function indexTree(root){
      state.flat = [];
      state.parentById.clear();
      state.nodeById.clear();
      state.childrenById.clear();

      function walk(node, parentId){
        state.flat.push(node);
        state.nodeById.set(node.id, node);
        state.parentById.set(node.id, parentId ?? null);
        if (node.children?.length){
          state.childrenById.set(node.id, node.children.map(c => c.id));
          for (const ch of node.children) walk(ch, node.id);
        } else {
          state.childrenById.set(node.id, []);
        }
      }
      walk(root, null);
    }

    function normalize(s){ return (s || "").toString().trim().toLowerCase(); }

    function matchesQuery(node, q){
      if (!q) return true;
      const hay = [
        node.name, node.code, node.short, node.why,
        ...(node.tags || []),
      ].map(normalize).join(" ");
      return hay.includes(q);
    }

    function hasMatchingDescendant(nodeId, q){
      const kids = state.childrenById.get(nodeId) || [];
      for (const kidId of kids){
        const kid = state.nodeById.get(kidId);
        if (!kid) continue;
        if (matchesQuery(kid, q)) return true;
        if (hasMatchingDescendant(kidId, q)) return true;
      }
      return false;
    }

    function buildVisibleSet(q){
      const visible = new Set();
      for (const node of state.flat){
        const ok = matchesQuery(node, q);
        const descendantOk = hasMatchingDescendant(node.id, q);
        if (ok || descendantOk) visible.add(node.id);
      }
      return visible;
    }

    function renderTree(){
      const q = normalize(state.lastQuery);
      const visible = buildVisibleSet(q);

      let shownCount = 0;

      function renderNode(node, depth=0){
        if (!visible.has(node.id)) return "";

        shownCount++;

        const children = node.children || [];
        const hasChildren = children.length > 0;

        const shouldExpand = q
          ? (state.expanded.has(node.id) || hasMatchingDescendant(node.id, q))
          : state.expanded.has(node.id);

        const isActive = state.activeId === node.id;
        const branchId = getBranchId(node);
        const dotColor = BRANCH_COLORS[branchId] || BRANCH_COLORS.root;

        const tog = hasChildren
          ? `<span class="tog" data-tog="${node.id}" title="${shouldExpand ? "Свернуть" : "Развернуть"}">${shouldExpand ? "−" : "+"}</span>`
          : `<span class="tog" style="opacity:.35;border-style:dashed">·</span>`;

        const html = `
          <div class="node ${isActive ? "active" : ""}" data-id="${node.id}">
            <span class="dot" style="opacity:${Math.max(0.35, 1 - depth*0.08)};background:${dotColor}"></span>
            <div class="meta">
              <div class="name" title="${escapeHtml(node.name)}">${escapeHtml(node.name)}</div>
              <div class="code">${escapeHtml(node.code || node.id)}</div>
            </div>
            ${tog}
          </div>
          ${hasChildren && shouldExpand
            ? `<div class="children">${children.map(ch => renderNode(ch, depth+1)).join("")}</div>`
            : ``}
        `;
        return html;
      }

      $tree.innerHTML = renderNode(METRIC_TREE);
      setCountShown(String(shownCount));
      wireTreeEvents();
    }

    function wireTreeEvents(){
      // Node click
      $tree.querySelectorAll(".node").forEach(el => {
        el.addEventListener("click", (e) => {
          const id = el.getAttribute("data-id");
          // If click on toggler, ignore here (handled below)
          if (e.target && e.target.getAttribute && e.target.getAttribute("data-tog")) return;
          setActive(id);
        });
      });

      // Toggle click
      $tree.querySelectorAll("[data-tog]").forEach(el => {
        el.addEventListener("click", (e) => {
          e.stopPropagation();
          const id = el.getAttribute("data-tog");
          toggleExpand(id);
        });
      });
    }

    function toggleExpand(id){
      if (state.expanded.has(id)) state.expanded.delete(id);
      else state.expanded.add(id);
      renderTree();
    }

    function expandAll(){
      for (const node of state.flat){
        if ((node.children || []).length) state.expanded.add(node.id);
      }
      renderTree();
    }

    function collapseAll(){
      state.expanded.clear();
      renderTree();
    }

    function getPath(id){
      const path = [];
      let cur = id;
      while (cur){
        const n = state.nodeById.get(cur);
        if (!n) break;
        path.push(n);
        cur = state.parentById.get(cur);
      }
      return path.reverse();
    }

    // Цвета второго уровня дерева (ветки): dot в списке + active нода в графе
    const BRANCH_COLORS = {
      root: "#7aa2ff",
      nsm: "#55b4d4",
      acq: "#6b7de0",
      act: "#9d6bdd",
      eng: "#e06b9d",
      ret: "#e08c6b",
      mon: "#e0c16b",
      qual: "#6be08c",
      ue: "#6be0c1"
    };
    function getBranchId(node){
      const path = getPath(node.id);
      return path.length > 1 ? path[1].id : "root";
    }
    function hexToRgba(hex, a){
      const m = hex.slice(1).match(/.{2}/g);
      if (!m) return `rgba(122,162,255,${a})`;
      const [r,g,b] = m.map(x => parseInt(x, 16));
      return `rgba(${r},${g},${b},${a})`;
    }

    function getNodeByCode(code){
      if (!code) return null;
      const c = String(code).trim();
      for (const node of state.flat){
        if (node.code === c || node.id === c || node.id === c.toLowerCase()) return node;
      }
      return null;
    }

    function renderMetricGraph(node){
      const parentId = state.parentById.get(node.id) ?? null;
      const parent = parentId ? state.nodeById.get(parentId) : null;
      const children = state.childrenById.get(node.id) || [];
      const childNodes = children.map(id => state.nodeById.get(id)).filter(Boolean);
      const relatedCodes = node.related || [];
      const relatedNodes = relatedCodes.map(getNodeByCode).filter(Boolean);
      const seen = new Set([node.id]);
      const others = [];
      if (parent && !seen.has(parent.id)){ seen.add(parent.id); others.push({ n: parent, role: "parent" }); }
      childNodes.forEach(n => { if (!seen.has(n.id)){ seen.add(n.id); others.push({ n: n, role: "child" }); } });
      relatedNodes.forEach(n => { if (!seen.has(n.id)){ seen.add(n.id); others.push({ n: n, role: "related" }); } });
      if (others.length === 0 && !parent && childNodes.length === 0) return "";

      const nodeW = 135;
      const padX = 12;
      const padY = 8;
      const lineHeight = 14;
      const charsPerLine = 26;

      function wrapLabel(text){
        const words = text.trim().split(/\s+/);
        const lines = [];
        let line = "";
        for (const word of words){
          const next = line ? line + " " + word : word;
          if (next.length <= charsPerLine){
            line = next;
          } else {
            if (line) lines.push(line);
            line = word.length <= charsPerLine ? word : word.slice(0, charsPerLine - 1) + "‑";
          }
        }
        if (line) lines.push(line);
        return lines.length ? lines : [""];
      }

      function nodeSize(n){
        const raw = (n.name || n.code || n.id).trim();
        const lines = wrapLabel(raw);
        const h = padY * 2 + lines.length * lineHeight;
        return { lines, w: nodeW, h };
      }

      let leftNodes, rightNodes;
      if (node.id === "root") {
        // Верхний уровень: только ноды второго уровня (как в treeScroll), пополам слева и справа
        const all = others.filter(x => x.role === "child").map(x => x.n);
        const half = Math.ceil(all.length / 2);
        leftNodes = all.slice(0, half);
        rightNodes = all.slice(half);
      } else {
        leftNodes = others.filter(x => x.role === "parent").map(x => x.n);
        rightNodes = [...others.filter(x => x.role === "child").map(x => x.n), ...others.filter(x => x.role === "related").map(x => x.n)];
      }

      const colLeft = 90;
      const colCenter = 270;
      const colRight = 450;
      const totalW = 540;
      // Между нод: вертикальный шаг между нодами (меньше — плотнее)
      const rowStep = 36;
      const totalH = Math.max(100, 40 + Math.max(leftNodes.length, rightNodes.length + 1) * rowStep);

      const positions = new Map();
      const nodeInfo = new Map();

      function placeNode(n, x, y){
        const { lines, w, h } = nodeSize(n);
        nodeInfo.set(n.id, { x, y, w, h, lines });
        positions.set(n.id, { x, y, w, h });
      }

      const cy = totalH / 2;
      placeNode(node, colCenter, cy);

      leftNodes.forEach((n, i) => {
        const y = leftNodes.length === 1 ? cy : 28 + (i / Math.max(1, leftNodes.length - 1)) * (totalH - 56);
        placeNode(n, colLeft, y);
      });

      rightNodes.forEach((n, i) => {
        const y = rightNodes.length === 1 ? cy : 28 + (i / Math.max(1, rightNodes.length - 1)) * (totalH - 56);
        placeNode(n, colRight, y);
      });

      const edges = [];
      if (parent) edges.push({ from: parent.id, to: node.id });
      leftNodes.forEach(n => edges.push({ from: node.id, to: n.id }));
      rightNodes.forEach(n => edges.push({ from: node.id, to: n.id }));

      const allNodes = [node, ...leftNodes, ...rightNodes];
      const lines = edges.map(e => {
        const a = nodeInfo.get(e.from);
        const b = nodeInfo.get(e.to);
        if (!a || !b) return "";
        const x1 = a.x + a.w / 2;
        const y1 = a.y;
        const x2 = b.x - b.w / 2;
        const y2 = b.y;
        return `<line class="graphLink" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`;
      }).join("");

      const parentIdForClass = parent ? parent.id : null;
      const activeBranchColor = BRANCH_COLORS[getBranchId(node)] || BRANCH_COLORS.root;
      const nodeEls = allNodes.map(n => {
        const info = nodeInfo.get(n.id);
        if (!info) return "";
        const isActive = n.id === node.id;
        const isParent = n.id === parentIdForClass;
        const fill = isActive ? hexToRgba(activeBranchColor, 0.22) : isParent ? "rgba(13,13,13,.95)" : "rgba(20,20,20,.9)";
        const rectStroke = isActive ? activeBranchColor : "";
        const textFill = isActive ? activeBranchColor : "";
        const classes = ["graphNode", isActive ? "active" : "", isParent ? "parent" : ""].filter(Boolean).join(" ");
        const { x, y, w, h, lines } = info;
        const rx = 8;
        const startY = -((lines.length - 1) * lineHeight) / 2;
        const tspans = lines.map((line, i) =>
          `<tspan x="0" dy="${i === 0 ? startY : lineHeight}" text-anchor="middle">${escapeHtml(line)}</tspan>`
        ).join("");
        const rectStyle = rectStroke ? `stroke:${rectStroke};stroke-width:2;filter:drop-shadow(0 0 6px ${hexToRgba(activeBranchColor, 0.4)})` : "";
        const textStyle = textFill ? `fill:${textFill};font-weight:700` : "";
        return `<g class="${classes}" data-id="${n.id}" transform="translate(${x},${y})">
          <rect x="${-w/2}" y="${-h/2}" width="${w}" height="${h}" rx="${rx}" ry="${rx}" fill="${fill}" ${rectStyle ? `style="${rectStyle}"` : ""}/>
          <text y="0" dy="0" ${textStyle ? `style="${textStyle}"` : ""}>${tspans}</text>
        </g>`;
      }).join("");

      return `
        <div class="metricGraph">
          <h3>Связи метрик</h3>
          <svg class="metricGraphSvg" viewBox="0 0 ${totalW} ${totalH}" xmlns="http://www.w3.org/2000/svg">
            ${lines}
            ${nodeEls}
          </svg>
        </div>
      `;
    }

    function setActive(id){
      state.activeId = id;
      const node = state.nodeById.get(id);
      if (!node) return;

      // Ensure parents expanded so selection stays visible
      const path = getPath(id);
      for (const p of path){
        if ((p.children || []).length) state.expanded.add(p.id);
      }

      setActiveCode(node.code || node.id);

      $detail.innerHTML = renderDetail(node);
      renderTree();
    }

    function renderDetail(node){
      const path = getPath(node.id);
      const graphHtml = renderMetricGraph(node);

      const crumbs = `
        <div class="crumbs">
          ${path.map(p => `<a href="#" data-jump="${p.id}">${escapeHtml(p.code || p.id)}</a>`).join("")}
        </div>
      `;

      const tags = (node.tags || []).length
        ? `<div class="footerNote">Теги: <span class="muted">${(node.tags || []).map(escapeHtml).join(", ")}</span></div>`
        : "";

      const formula = node.formula
        ? `<div class="box"><h3>Формула</h3><div class="p" style="margin:0;font-family:var(--mono)">${escapeHtml(node.formula)}</div></div>`
        : "";

      const improve = (node.howImprove || []).length
        ? `<ul>${node.howImprove.map(x => `<li>${escapeHtml(x)}</li>`).join("")}</ul>`
        : `<div class="muted">—</div>`;

      const pitfalls = (node.pitfalls || []).length
        ? `<ul>${node.pitfalls.map(x => `<li>${escapeHtml(x)}</li>`).join("")}</ul>`
        : `<div class="muted">—</div>`;

      const related = (node.related || []).length
        ? `<ul>${node.related.map(x => `<li><span style="font-family:var(--mono)">${escapeHtml(x)}</span></li>`).join("")}</ul>`
        : `<div class="muted">—</div>`;

      const body = `
        ${crumbs}
        ${graphHtml}

        <h2 class="h2">${escapeHtml(node.name)}</h2>
        <p class="p muted">${escapeHtml(node.short || "")}</p>

        <div class="grid">
          <div class="box">
            <h3>Зачем важно</h3>
            <p class="p" style="margin:0">${escapeHtml(node.why || "—")}</p>
          </div>
          ${formula || `<div class="box"><h3>Формула</h3><div class="muted">—</div></div>`}
        </div>

        <div class="grid" style="margin-top:10px">
          <div class="box">
            <h3>Как улучшать</h3>
            ${improve}
          </div>
          <div class="box">
            <h3>Ловушки</h3>
            ${pitfalls}
          </div>
        </div>

        <div class="box" style="margin-top:10px">
          <h3>Связанные метрики</h3>
          ${related}
        </div>

        ${tags}
      `;

      // wire breadcrumbs and graph nodes
      setTimeout(() => {
        $detail.querySelectorAll("[data-jump]").forEach(a => {
          a.addEventListener("click", (e) => {
            e.preventDefault();
            setActive(a.getAttribute("data-jump"));
          });
        });
        $detail.querySelectorAll(".graphNode[data-id]").forEach(el => {
          el.addEventListener("click", () => setActive(el.getAttribute("data-id")));
        });
      }, 0);

      return body;
    }

    function escapeHtml(str){
      return encodeHtml(str);
    }

    // Search
    let t = null;
    $q.addEventListener("input", () => {
      clearTimeout(t);
      t = setTimeout(() => {
        state.lastQuery = $q.value;
        renderTree();
      }, 80);
    });

    document.getElementById("expandAll").addEventListener("click", expandAll);
    document.getElementById("collapseAll").addEventListener("click", collapseAll);

    try {
      if (!METRIC_TREE) {
        throw new Error("METRIC_TREE не найден. Убедись, что tree.data.js подключен до main script.");
      }

      const problems = validateTree(METRIC_TREE);
      if (problems.length) {
        throw new Error(`Некорректная структура: ${problems[0]}`);
      }

      // Init
      indexTree(METRIC_TREE);

      // Default expand: top-level branches
      for (const child of (METRIC_TREE.children || [])) state.expanded.add(child.id);
      state.expanded.add(METRIC_TREE.id);

      renderTree();

      // По умолчанию выбран верхний уровень (root / tree)
      setActive(METRIC_TREE.id);
    } catch (err) {
      renderFatal(err && err.message ? err.message : String(err));
      console.error(err);
    }
  </script>
</body>
</html>
